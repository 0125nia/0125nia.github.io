<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:{
                    {
                    .Site.Params.AccentColor | default "#FF4D4D"
                }
            };--font-size:{
                    {
                    .Site.Params.FontSize | default "17.5px"
                }
            }}</style><title>MySQL中的锁</title>
<meta name=description content="全局锁 设在多个事务同时访问同一条数据时，冲突发生的概率较低，因此在操作数据时不会立即进行锁定，而是在提交数据更改时检查是否有其它事务修改了这条数据，若没有就提交更改，否则就回滚事务
MYSQL中并没有内置实现乐观锁，但可以通过一些技巧实现，常见的实现方式是使用版本号（或时间戳）字段，每当一条记录被修改时，就增加版本 …"><meta name=keywords content='mysql,concurrent'><meta property="og:url" content="https://0125nia.github.io/posts/mysql_lock/"><meta property="og:type" content="website"><meta property="og:title" content="MySQL中的锁"><meta property="og:description" content="全局锁 设在多个事务同时访问同一条数据时，冲突发生的概率较低，因此在操作数据时不会立即进行锁定，而是在提交数据更改时检查是否有其它事务修改了这条数据，若没有就提交更改，否则就回滚事务
MYSQL中并没有内置实现乐观锁，但可以通过一些技巧实现，常见的实现方式是使用版本号（或时间戳）字段，每当一条记录被修改时，就增加版本 …"><meta property="og:image" content="https://0125nia.github.io/avatar.webp"><meta property="og:image:secure_url" content="https://0125nia.github.io/avatar.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="MySQL中的锁"><meta name=twitter:description content="全局锁 设在多个事务同时访问同一条数据时，冲突发生的概率较低，因此在操作数据时不会立即进行锁定，而是在提交数据更改时检查是否有其它事务修改了这条数据，若没有就提交更改，否则就回滚事务
MYSQL中并没有内置实现乐观锁，但可以通过一些技巧实现，常见的实现方式是使用版本号（或时间戳）字段，每当一条记录被修改时，就增加版本 …"><meta property="twitter:domain" content="https://0125nia.github.io/posts/mysql_lock/"><meta property="twitter:url" content="https://0125nia.github.io/posts/mysql_lock/"><meta name=twitter:image content="https://0125nia.github.io/avatar.webp"><link rel=canonical href=https://0125nia.github.io/posts/mysql_lock/><link rel=stylesheet type=text/css href=/css/normalize.min.css media=print><link rel=stylesheet type=text/css href=/css/main.min.css><link id=dark-theme rel=stylesheet href=/css/dark.min.css><script src=/js/bundle.min.197a408bfce76c7f4dfcb6c76be67747b583e501ed17c0e7752e730167adf43f.js integrity="sha256-GXpAi/znbH9N/LbHa+Z3R7WD5QHtF8DndS5zAWet9D8="></script><link rel=stylesheet type=text/css href=/css/font.css></head><body><script>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=avatar><a href=https://0125nia.github.io/><img src=/avatar.webp alt=avatar></a></div><div class=nav-title><a class=nav-brand href=https://0125nia.github.io/>nia</a></div><div class=nav-links><div class=nav-link><a href=https://0125nia.github.io/ aria-label><span data-feather=home></span> Home</a></div><div class=nav-link><a href=https://0125nia.github.io/posts/ aria-label><span data-feather=book></span> Posts</a></div><div class=nav-link><a href=https://0125nia.github.io/tags/ aria-label><span data-feather=tag></span> Tags</a></div><div class=nav-link><a href=https://0125nia.github.io/projects/ aria-label><span data-feather=code></span> Projects</a></div><div class=nav-link><a href=https://github.com/0125nia aria-label=github><span data-feather=github></span></a></div><div class=nav-link><a href=https://juejin.cn/user/3987308744025273 aria-label=juejin><span data-feather=juejin></span></a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a aria-hidden=true role=switch><span class=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
<a aria-checked=false aria-labelledby=hamburger-menu-toggle id=hamburger-menu-toggle-target role=switch><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=https://0125nia.github.io/><span data-feather=home></span> Home</a></li><li class=nav-item><a href=https://0125nia.github.io/posts/><span data-feather=book></span> Posts</a></li><li class=nav-item><a href=https://0125nia.github.io/tags/><span data-feather=tag></span> Tags</a></li><li class=nav-item><a href=https://0125nia.github.io/projects/><span data-feather=code></span> Projects</a></li><li class=nav-item><a href=https://github.com/0125nia><span data-feather=github></span></a></li><li class=nav-item><a href=https://juejin.cn/user/3987308744025273><span data-feather=juejin></span></a></li><li class="nav-item dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a role=switch><span class=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>MySQL中的锁</h1><small role=doc-subtitle></small><p class=post-date>August 17, 2024
| Updated February 12, 2025</p><ul class=post-tags><li class=post-tag><a href=https://0125nia.github.io/tags/mysql>mysql</a></li><li class=post-tag><a href=https://0125nia.github.io/tags/concurrent>concurrent</a></li></ul></div><div class=post-content><h3 id=全局锁>全局锁</h3><blockquote><p>设在多个事务同时访问同一条数据时，冲突发生的概率较低，因此在操作数据时不会立即进行锁定，而是在提交数据更改时检查是否有其它事务修改了这条数据，若没有就提交更改，否则就回滚事务</p></blockquote><p>MYSQL中并没有内置实现乐观锁，但可以通过一些技巧实现，常见的实现方式是使用版本号（或时间戳）字段，每当一条记录被修改时，就增加版本号（或更新时间戳）。
在更新记录时，先检查版本号（或时间戳）是否和读取记录时的版本号（或时间戳）一致，如果一致则执行更新并增加版本号（或更新时间戳），否则拒绝更新</p><p><strong>优点</strong>：在大部分时间都不需要锁定，所以在冲突较少的情况下可以获得较高的并发性能，然而，如果冲突较多，那么乐观锁可能会导致大量的事务回滚，从而影响性能，因此，选择乐观锁还是其它锁定技术，需要根据实际的并发情况和性能需求来决定</p><p><strong>使用场景</strong></p><ul><li>低冲突环境</li><li>读多写少的场景：在读操作远多于写操作的情况下，乐观锁可以避免由于频繁的读操作导致不必要的锁定开销</li><li>短事务操作</li><li>分布式系统：由于网络延迟等原因，事务冲突的可能性较低，因此乐观锁是一个合适的选择</li><li>互联网应用：并发修改同一条数据的几率较小，因此使用乐观锁可以提高系统性能</li></ul><p><strong>缺点</strong>：</p><ul><li>冲突检测</li><li>处理开销：冲突发生时需要进行回滚和重试，可能会增加系统的开销，在一些场景中可能会导致性能下降</li><li>版本管理：乐观锁通常通过版本号（或时间戳）来检测冲突</li><li>编程复杂性：使用乐观锁需要更复杂的编程，程序需要处理可能发生的冲突和重试</li></ul><p>有效的并发控制策略，在冲突较多的情况下可能会带来更大的开销和编程复杂性，因此是否使用乐观锁现需要根据应用的具体需求和场景来决定</p><hr><h3 id=表锁>表锁</h3><blockquote><p>mysql中最基本的锁策略
表级锁开销小、加锁快，不会出现死锁
锁定粒度大，发生锁冲突的概率最高
并发度最低</p></blockquote><p>表共享读锁(Table Read Lock)：表读锁，允许一个事务锁定的表进行读取操作，不允许其它事务对其进行写操作，但可以进行读操作，读锁之间是不会互相阻塞的</p><p>表独占写锁（Table Write Lock）表写锁 允许一个事务锁定的表进行读取和写入（更新）操作，但其它任何事务都不能再对该表进行任何操作，必须等待表写锁结束，写锁会阻塞其它所有锁，包括读锁和写锁</p><p>在MySQL中对MylSAM表的读操作，会自动加上读锁，对MylSAM表的写操作，会自动加上写锁</p><p>InnoDB引擎在必要的情况下会使用表锁，但主要是使用行锁来实现多版本并发控制（MVCC）能提供更好的并发性能和更少的锁冲突</p><p>适用读操作多，写操作少的应用，当并发争用5不是特别激烈，以及记录级锁并发控制开销大于访问冲突开销的情况，在并发度高，或写操作较多的情况下，表锁可能会成为瓶颈</p><p><strong>使用场景</strong></p><ul><li><p>读密集型</p></li><li><p>写操作不频繁的场景</p></li><li><p>数据量不大的简单应用</p></li><li><p>全表更新或删除</p></li></ul><p>虽然表级锁的开销小，但由于其锁定粒度大，可能会导致并发度下降</p><p>MYSQL中会发生表级锁的命令</p><ul><li><code>ALTER TABLE</code></li><li><code>DROP TABLE</code> & <code>TRUNCATE TABLE</code> 删除整个表以及删除表中的所有数据</li><li><code>LOCK TABLES</code></li><li>MYlSAM存储引擎，全表扫描或大范围扫描</li><li>全局锁</li></ul><p><strong>表锁的风险点</strong></p><ul><li>性能下降：在高并发的环境中可能导致大量的请求阻塞，从而降低性能，对于读取和写入混合密集的负载，表锁可能会成为一个性能瓶颈</li><li>并发性能差：一旦一个线程对表加了写锁，其它线程的任何读写操作都会被阻塞，直到写锁被释放，同样的，如果一个读锁被持有，那么其它的写操作将被阻塞，这就使得并发性能大大降低</li><li>可能导致锁等待和超时：在高并发的环境中，由于表级锁的粒度较大，可能会有很多线程在等待锁，如果等待的时间过长，可能会导致锁超时，进一步影响应用的性能和可用性</li><li>写操作影响大</li><li>死锁的可能性：表锁本身不会出现死锁，但在多表操作中，若没有按照一定的顺序获得锁，可能会导致读锁</li></ul><p>为避免此类问题，通常会选择InnoDB存储引擎，主要使用行级锁，可提供更好的并发性能，并在一定程度上减少锁争用的问题
并且InnoDB支持事务，可保证数据的一致性和完整性，在实际应用中，我们应根据具体的业务需求和系统负载，选择合适的存储引擎和锁策略</p><hr><h3 id=行锁>行锁</h3><blockquote><p>单表中单行进行锁定</p></blockquote><p>相比于表级锁和页锁，行级锁的粒度更小，因此在处理高并发事务时，能提供更好的并发性能和更少的锁冲突，然而，行级锁也需要更多的内存和CPU资源，需要对每一行都进行管理</p><p>在MYSQL中行级锁主要有InnoDB提供，InnoDB支持两种类型的行级锁</p><ul><li>共享锁（S锁）读锁</li><li>排他锁（X锁）写锁</li></ul><p>在实际应用中InnoDB还提供了一种间隙锁的特性，不仅锁定一个具体的行，还锁定其前后的间隙，可以防止其它事务插入新的行到已锁定行的前后，从而解决一些并发问题</p><p><strong>使用场景</strong></p><ul><li>高并发读写操作</li><li>单行操作</li><li>短期锁</li><li>实现并发控制</li><li>复杂的事务处理</li></ul><p>由于行级锁的锁定粒度较小，可能消耗更多的系统资源（例如内存和CPU），特别是在处理大量数据时，此外使用行级锁也可能导致死锁，需要使用合适的策略来避免死锁，例如在事务中按照一定的顺序锁定行</p><p>发生行锁的命令</p><ul><li><code>Select ... FOR UPDATE</code> X</li><li><code>Select ... LOCK IN SHARE MODE</code> S</li><li><code>INSERT</code> X</li><li><code>UPDATE</code> X</li><li><code>DELETE</code> X</li></ul><p><strong>MYSQL行锁风险</strong></p><ul><li>死锁： 粒度越小需要消耗资源更多，当两个或更多的事务相互等待对方释放资源时，就会发生死锁</li><li>锁升级：若一个事务试图锁定的行过多，InnoDB可能会将锁从行级升级到表级，这就可能导致更多的锁冲突</li><li>锁等待：如果一个事务已经锁定了某行，其它试图访问这行的事务就必须等待，可能导致性能下降</li><li>资源消耗：行级锁需要更多的内存来存储锁信息，而且需要更多的CPU时间来处理锁请求和释放锁</li><li>难以调试和排查：若出现性能问题或锁冲突，可能需要复杂的调试和排查工作来找出问题的原因</li><li>事务隔离级别：不同的事务隔离级别会影响锁的行为和性能，可能需要根据具体的应用场景来调整事务隔离级别</li></ul><hr><h3 id=乐观锁>乐观锁</h3><blockquote><p>假设在多个事务同时访问同一条数据时，冲突发生的概率较低，因此在操作数据时不会立即进行锁定，而是在提交数据更改时检查是否有其它事务修改了这条数据，若没有就提交更改，否则就回滚事务</p></blockquote><p>MYSQL中并没有内置实现乐观锁，但可以通过一些技巧实现，常见的实现方式是使用版本号（或时间戳）字段，每当一条记录被修改时，就增加版本号（或更新时间戳）。
在更新记录时，先检查版本号（或时间戳）是否和读取记录时的版本号（或时间戳）一致，如果一致则执行更新并增加版本号（或更新时间戳），否则拒绝更新</p><p><strong>优点</strong>：在大部分时间都不需要锁定，所以在冲突较少的情况下可以获得较高的并发性能，然而，如果冲突较多，那么乐观锁可能会导致大量的事务回滚，从而影响性能，因此，选择乐观锁还是其它锁定技术，需要根据实际的并发情况和性能需求来决定</p><p><strong>使用场景</strong></p><ul><li>低冲突环境</li><li>读多写少的场景：在读操作远多于写操作的情况下，乐观锁可以避免由于频繁的读操作导致不必要的锁定开销</li><li>短事务操作</li><li>分布式系统：由于网络延迟等原因，事务冲突的可能性较低，因此乐观锁是一个合适的选择</li><li>互联网应用：并发修改同一条数据的几率较小，因此使用乐观锁可以提高系统性能</li></ul><p><strong>缺点</strong>：</p><ul><li>冲突检测</li><li>处理开销：冲突发生时需要进行回滚和重试，可能会增加系统的开销，在一些场景中可能会导致性能下降</li><li>版本管理：乐观锁通常通过版本号（或时间戳）来检测冲突</li><li>编程复杂性：使用乐观锁需要更复杂的编程，程序需要处理可能发生的冲突和重试</li></ul><p>有效的并发控制策略，在冲突较多的情况下可能会带来更大的开销和编程复杂性，因此是否使用乐观锁现需要根据应用的具体需求和场景来决定</p><hr><h3 id=悲观锁>悲观锁</h3><blockquote><p>认为数据在并发除里过程中很可能会出现冲突，为了保证数据的完整性和一致性，每次在读写数据时都会先加锁，这样可以避免其它事务进行并发的读写操作</p></blockquote><p><strong>使用场景</strong></p><ul><li>写操作较多的场景</li><li>并发冲突高的场景</li><li>业务需要强一致性的场景</li></ul><p>悲观锁也可能引入死锁等问题，也可能因为锁定过程中事务长时间等待而影响性能</p><p><strong>MYSQL使用悲观锁</strong></p><ul><li><code>SELECT ... FOR UPDATE</code> 在所选行上设置排他锁</li><li><code>SELECT ... LOCK IN SHARE MODE</code> 在所选行上设置共享锁</li></ul><p><strong>缺点</strong></p><ul><li>性能开销：锁定资源会影响到系统性能，每次对数据的读写都需要进行加锁和解锁的操作，势必会增加系统开销，特别是在高并发的环境下，锁的竞争更会严重影响到系统性能</li><li>并发程度低：悲观锁在操作数据前就会加锁，导致在同一时间，只有一个事务能操作数据，其它数据只能等待，大大降低了系统的并发度</li><li>死锁</li><li>锁超时：事务长时间持有锁而不释放，可能导致其它等待锁的事务超时，不仅可能导致等待的事务失败，还可能影响到整个系统的稳定性</li></ul><hr><h3 id=意向共享锁和意向排他锁>意向共享锁和意向排他锁</h3><p>意向锁是表锁，为了协调<em>行锁</em>和<em>表锁</em>的关系，支持多粒度（表锁和行锁）的锁并存</p><p>当事务A有行锁时，MYSQL会自动为该表添加意向锁
事务B如果想申请整个表的写锁，那么不需要遍历每一行判断是否存在行锁
而是直接判断是否存在意向锁，增加性能</p><p><strong>意向锁的兼容互斥性</strong></p><table><thead><tr><th></th><th>意向共享锁（IS）</th><th>意向排他锁（IX）</th></tr></thead><tbody><tr><td>共享锁（S）</td><td>兼容</td><td>互斥</td></tr><tr><td>排他锁（X）</td><td>互斥</td><td>互斥</td></tr></tbody></table><hr><h3 id=间隙锁>间隙锁</h3><p>Gap Locks 是 MySQL InnoDB存储引擎提供的一种锁定机制
锁定的不是具体的行记录，而是两个索引之间的间隙（或称为区间）这样可以防止新的记录插入到该gap，确保数据的一致性和事务的隔离性</p><p>间隙锁常常和记录锁一起使用，共享形成Next-Key锁
保护索引记录的范围查询和扫描操作</p><p><strong>间隙锁主要类型</strong></p><ul><li>区间-区间间隙锁：锁定两个索引键之间的间隙，或者是第一个索引键之间的间隙</li><li>区间-记录间隙锁：锁定一个索引键和一个记录之间的间隙</li><li>记录-区间间隙锁：锁定一个记录和一个索引键之间的间隙</li></ul><p>间隙锁的存在主要是为了解决<strong>幻读</strong>问题</p><p>幻读指在一个事务内读取某个范围的记录时，另外一个事务在该范围内插入了新的记录，当第一个事务再次读取该范围的记录时，会发现有些原本不存在的记录，这就是幻读</p><p><strong>使用场景</strong></p><ul><li>避免幻读</li><li>范围查询</li></ul><p><strong>缺点</strong></p><ul><li>性能影响：间隙锁会阻止其它事务在已经锁定的范围内插入新的行，这可能会影响到数据库的并发性能，尤其在需要大量插入操作的高并发场景下</li><li>死锁风险</li><li>复杂性</li><li>锁定范围可能过大：可能会比实际需要锁定的行多，若一个事务需要锁定的只是表中的一小部分行，但由于间隙锁的存在，可能会锁定更大范围的数据，导致不必要的锁定冲突</li></ul><hr><h3 id=临键锁和记录锁>临键锁和记录锁</h3><p>临键锁 Next-Key 可以理解为一种特殊的间隙锁， 也可以理解为一种特殊的算法，通过临键锁可以解决幻读的问题，每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段<em>左开右闭</em>区间的数据，InnoDB中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列上不存在临键锁</p><p>记录锁 Record Lock ，主要用于锁定和控制对单个行记录的访问，记录锁是在索引记录上设置的，对于表没有主键或唯一索引的表，InnoDB会生成一个隐藏的聚簇索引，并在这个隐藏索引上加锁</p></div><div class=prev-next></div></div><aside class=post-toc><nav id=toc><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#全局锁>全局锁</a></li><li><a href=#表锁>表锁</a></li><li><a href=#行锁>行锁</a></li><li><a href=#乐观锁>乐观锁</a></li><li><a href=#悲观锁>悲观锁</a></li><li><a href=#意向共享锁和意向排他锁>意向共享锁和意向排他锁</a></li><li><a href=#间隙锁>间隙锁</a></li><li><a href=#临键锁和记录锁>临键锁和记录锁</a></li></ul></li></ul></li></ul></nav></nav></aside></main><footer class=footer><span>&copy; 2024-2025 nia</span>
<span>Powered by <a target=_blank href=https://gohugo.io>hugo</a> & <a target=_blank href=https://github.com/gokarna-theme/gokarna-hugo>Gokarna</a></span></footer></body></html>