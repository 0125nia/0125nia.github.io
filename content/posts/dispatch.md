---
date: 2024-12-24T23:32:03+08:00
description: "这是一个关于操作系统中的进程调度的讨论"
# image: ""
lastmod: 2025-02-08
showTableOfContents: true
tags: ["os"]
title: "调度策略 SJF、STCF 与 RR"
type: "post"
---

### 周转时间和响应时间

首先我们明确一下两个概念
周转时间与响应时间

- 周转时间（Turnaround Time）
  一个进程从提交到系统开始执行，到完全完成所花的总时间
  是一个进程从开始到结束所经历的总时间，包括等待时间、执行时间和 I/O 操作时间。

- 响应时间（Response Time）
  一个进程从提交到系统开始运行第一次指令所花的时间
  是进程首次获得 CPU 的时间，衡量用户对系统响应的感知速度。

简单来说

周转时间就是从任务提交到任务执行完成的时间，是整个任务生命周期的长短

响应时间就类似，你把任务拿给操作系统，到操作系统开始搭理你，开始执行你的任务的这个等待的时间

### SJF(Shortest Job First)

最短任务优先代表一个总体调度原则，可以应用于所有重视平均用户周转时间的系统

考虑到所有工作同时到达的假设，我们可以认为 SJF 确实是一个最优的调度算法

但仍然有不适用的情况，我们这里引用[OSTEP](https://pages.cs.wisc.edu/~remzi/OSTEP/)的例子

![SJF_flaw](/img/post/dispatch_SJF_flaw.png)


也就是说，如果周转时间为 100s 的 A 任务在 0s 时到达并执行，而当 A 任务执行到 10s 时又有周转时间均为 10s 的 B 任务与 C 任务到达，如果是 SJF 策略的话，B 与 C 需要等待 A 任务执行完毕之后，才开始执行，此时 B 与 C 任务的周转时间就大大提高了，这并不是我们预期的结果

### STCF(Shortest Time to Completion First)

为了解决以上的问题，我们可以允许任务在未执行完时切换到另外的一个周转时间短的任务进行执行
也就是在 SJF 的基础上添加抢占的特性

STCF 也可称为 PSJF(Preemptive Shortest Job First)

每当新的任务进入，系统就会确定剩余任务和新任务中哪个的剩余时间最少，然后调度该工作。

### RR(Round Robin)

轮转

在一个时间片里运行一个任务，时间片结束后，切换到运行队列中的下一个任务
如此反复执行，直到所有的任务执行完成

但与此同时，时间片的长短对于 RR 是至关重要的
时间片越短，RR 在响应时间上表现越好，但上下文切换的成本也因此增多，影响整体性能

因此，系统设计者需要权衡时间片的长度，使其足够长，以便减弱上下文切换带来的成本(摊销，amortize)，又不会使系统不及时响应。

如果注重响应时间，那么带有合理时间片的 RR，就会是非常好的调度程序
但如果注重周转时间，那 RR 甚至是最差的，很多情况下甚至比简单的 FIFO 更差

> 另外的，还有一种策略是 FIFO
> 它是简单且易于实现的，但也存在着明显的缺陷，我们在此不讨论

### 区别

#### 公平性

- SJF/STCF：不公平，倾向于优先处理短任务，可能导致长任务饥饿
- RR：公平，每个进程都有相等机会运行

#### 上下文切换开销

- SJF/STCF：上下文切换发生频率较低，特别是抢占式 SJF
- RR：上下文切换频繁，时间片越短，切换开销越大

#### 抢占与否

- 非抢占式
  - SJF：除非当前任务完成，否则不会切换到其它任务
- 抢占式
  - STCF：当前任务可能会被周转时间短的任务抢占
  - RR：在当前时间片用完后切换到下一个任务

我们讨论了两种调度策略
SJF、STCF 优化周转时间，但对响应时间不利
RR 优化响应时间，但对周转时间不利
但这仅仅是建立在假设任务没有 IO 以及每个任务的运行时间是已知的，这两个的前提下的
如果加上这两个因素，情况会更加的复杂，我们在后面会进行讨论
