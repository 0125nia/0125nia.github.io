<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>nia</title><link>https://0125nia.github.io/</link><description>Recent content on nia</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Fri, 28 Feb 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://0125nia.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://0125nia.github.io/hide/tips/</link><pubDate>Fri, 28 Feb 2025 22:23:15 +0800</pubDate><guid>https://0125nia.github.io/hide/tips/</guid><description>&lt;h1 id="tips">Tips&lt;/h1>
&lt;h2 id="o-文件复制到u盘">[o] 文件复制到U盘&lt;/h2>
&lt;p>文件复制到U盘显示&lt;code>对于目标文件系统，文件XXX过大。&lt;/code>&lt;/p>
&lt;p>这一般是因为U盘的文件系统不支持单个文件超过某个大小限制&lt;/p>
&lt;p>如果U盘是 FAT32 文件系统，单个文件的最大大小限制是 &lt;strong>4GB&lt;/strong>&lt;/p>
&lt;p>通过&lt;strong>格式化&lt;/strong>来修改U盘的文件系统为&lt;code>exFAT&lt;/code>或&lt;code>NTFS&lt;/code>即可解决&lt;/p>
&lt;h2 id="go-数据传输时某个字段为初始值">[go] 数据传输时某个字段为初始值&lt;/h2>
&lt;p>在传输前是有值的，传输后变为初始值
一般是因为这个数据传输只会读取结构体中首字母大写的字段 其它则不被序列化
检查该字段是否没有首字母大写&lt;/p></description></item><item><title/><link>https://0125nia.github.io/hide/miscellaneous/</link><pubDate>Thu, 13 Feb 2025 22:23:15 +0800</pubDate><guid>https://0125nia.github.io/hide/miscellaneous/</guid><description>&lt;p>&lt;a href="https://github.com/sdcuike/Clean-Code-Collection-Books">https://github.com/sdcuike/Clean-Code-Collection-Books&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/orgs/community/discussions/151824">https://github.com/orgs/community/discussions/151824&lt;/a>&lt;/p></description></item><item><title>Projects</title><link>https://0125nia.github.io/projects/</link><pubDate>Wed, 12 Feb 2025 00:33:15 +0800</pubDate><guid>https://0125nia.github.io/projects/</guid><description>&lt;hr>
&lt;div style="display: inline-block; padding: 10px;">
 
 
 
 
 

 
 &lt;a href=" ./mercury" target="_blank">
 &lt;img src="https://0125nia.github.io/img/project/mercury_temp.png"
 style="width: 300px; height: 150px; object-fit: cover; border-radius: 10px;">
 &lt;/a>
 
 
 &lt;p style="text-align: center; margin-top: 5px; font-size: 14px;">Mercury - 手写im系统 - Go&lt;/p>
 
&lt;/div>
&lt;div style="display: inline-block; padding: 10px;">
 
 
 
 
 

 
 &lt;a href=" ./mit65840" target="_blank">
 &lt;img src="https://0125nia.github.io/img/project/65840.png"
 style="width: 300px; height: 150px; object-fit: cover; border-radius: 10px;">
 &lt;/a>
 
 
 &lt;p style="text-align: center; margin-top: 5px; font-size: 14px;">mit6.5840(mit6.824) - 分布式系统 - Go&lt;/p>
 
&lt;/div>
&lt;div style="display: inline-block; padding: 10px;">
 
 
 
 
 

 
 &lt;a href=" ./interpreter" target="_blank">
 &lt;img src="https://0125nia.github.io/img/project/interpreter.png"
 style="width: 300px; height: 150px; object-fit: cover; border-radius: 10px;">
 &lt;/a>
 
 
 &lt;p style="text-align: center; margin-top: 5px; font-size: 14px;">Interpreter for lox - Rust&lt;/p>
 
&lt;/div>
&lt;div style="display: inline-block; padding: 10px;">
 
 
 
 
 

 
 &lt;a href=" ./echo_dispatch" target="_blank">
 &lt;img src="https://0125nia.github.io/img/project/echodispatch.png"
 style="width: 300px; height: 150px; object-fit: cover; border-radius: 10px;">
 &lt;/a>
 
 
 &lt;p style="text-align: center; margin-top: 5px; font-size: 14px;">EchoDispatch - 消息推送系统 - Java&lt;/p></description></item><item><title/><link>https://0125nia.github.io/hide/nav/</link><pubDate>Sat, 08 Feb 2025 18:52:50 +0800</pubDate><guid>https://0125nia.github.io/hide/nav/</guid><description>&lt;a href="https://0125nia.github.io/hide/nav/#Nav" style="text-decoration: none;">
 &lt;h1 id="Nav" class="bonkers-font" style="font-size: 1.5em;">
 
 Nav
 

 &lt;/h1>
&lt;/a>

&lt;div class="dw-font">
 
&lt;div style="padding: 10px;">
 
 
 
 &lt;a class="hover_link_l" href=" ./../collect" target="_blank">
 Collect - Man is a tool using animal. Without tools, he is nothing. With tools, he is all.
 &lt;/a>
&lt;/div>

&lt;style>
 
 
 .hover_link_l {
 text-decoration: none;
 font-size: 1.5em;
 }

 
 .hover_link_l {
 color: inherit;
 line-height: 2;
 position: relative;
 }

 .hover_link_l::before {
 content: '';
 width: 0;
 height: 2px;
 border-radius: 2px;
 background-color: currentColor;
 position: absolute;
 bottom: -.25rem;
 right: 0;
 transition: right .5s, width .5s, left .5s;
 }

 .hover_link_l:hover {
 color: inherit;
 }

 .hover_link_l:hover::before {
 width: 100%;
 left: 0;
 }
&lt;/style>

&lt;div style="padding: 10px;">
 
 
 
 &lt;a class="hover_link_l" href=" ./../rust_study" target="_blank">
 rust study
 &lt;/a>
&lt;/div>

&lt;style>
 
 
 .hover_link_l {
 text-decoration: none;
 font-size: 1.5em;
 }

 
 .hover_link_l {
 color: inherit;
 line-height: 2;
 position: relative;
 }

 .hover_link_l::before {
 content: '';
 width: 0;
 height: 2px;
 border-radius: 2px;
 background-color: currentColor;
 position: absolute;
 bottom: -.25rem;
 right: 0;
 transition: right .5s, width .5s, left .5s;
 }

 .hover_link_l:hover {
 color: inherit;
 }

 .hover_link_l:hover::before {
 width: 100%;
 left: 0;
 }
&lt;/style>

&lt;div style="padding: 10px;">
 
 
 
 &lt;a class="hover_link_l" href=" ./../go_study" target="_blank">
 golang study
 &lt;/a>
&lt;/div>

&lt;style>
 
 
 .hover_link_l {
 text-decoration: none;
 font-size: 1.5em;
 }

 
 .hover_link_l {
 color: inherit;
 line-height: 2;
 position: relative;
 }

 .hover_link_l::before {
 content: '';
 width: 0;
 height: 2px;
 border-radius: 2px;
 background-color: currentColor;
 position: absolute;
 bottom: -.25rem;
 right: 0;
 transition: right .5s, width .5s, left .5s;
 }

 .hover_link_l:hover {
 color: inherit;
 }

 .hover_link_l:hover::before {
 width: 100%;
 left: 0;
 }
&lt;/style>

&lt;div style="padding: 10px;">
 
 
 
 &lt;a class="hover_link_l" href=" ./../tips" target="_blank">
 some tips - Maybe useful
 &lt;/a>
&lt;/div>

&lt;style>
 
 
 .hover_link_l {
 text-decoration: none;
 font-size: 1.5em;
 }

 
 .hover_link_l {
 color: inherit;
 line-height: 2;
 position: relative;
 }

 .hover_link_l::before {
 content: '';
 width: 0;
 height: 2px;
 border-radius: 2px;
 background-color: currentColor;
 position: absolute;
 bottom: -.25rem;
 right: 0;
 transition: right .5s, width .5s, left .5s;
 }

 .hover_link_l:hover {
 color: inherit;
 }

 .hover_link_l:hover::before {
 width: 100%;
 left: 0;
 }
&lt;/style>


&lt;/div>
&lt;hr>







&lt;a href="https://0125nia.github.io/hide/nav/#" style="text-decoration: none;">
 &lt;h1 id="" class="bonkers-font" style="font-size: 1.5em;">
 
 
 Some Articles

 

 &lt;/h1>
&lt;/a>

&lt;div class="yan-font">
 
&lt;div style="padding: 10px;">
 
 
 
 &lt;a class="hover_link_b" href=" https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way" target="_blank">
 提问的智慧
 &lt;/a>
&lt;/div>

&lt;style>
 
 
 .hover_link_b {
 text-decoration: none;
 font-size: 1.5em;
 }

 
 .hover_link_b {
 color: inherit;
 line-height: 2;
 position: relative;
 }

 .hover_link_b::before {
 content: '';
 width: 100%;
 height: 2px;
 border-radius: 2px;
 background-color: currentColor;
 position: absolute;
 bottom: -.5rem;
 left: 0;
 transition: transform .5s, opacity .5s;
 opacity: 0;
 }

 .hover_link_b:hover {
 color: inherit;
 }

 .hover_link_b:hover::before {
 transform: translateY(-.25rem);
 opacity: 1;
 }
&lt;/style>

&lt;div style="padding: 10px;">
 
 
 
 &lt;a class="hover_link_b" href=" https://github.com/firstcontributions/first-contributions" target="_blank">
 first-contributions
 &lt;/a>
&lt;/div>

&lt;style>
 
 
 .hover_link_b {
 text-decoration: none;
 font-size: 1.5em;
 }

 
 .hover_link_b {
 color: inherit;
 line-height: 2;
 position: relative;
 }

 .hover_link_b::before {
 content: '';
 width: 100%;
 height: 2px;
 border-radius: 2px;
 background-color: currentColor;
 position: absolute;
 bottom: -.5rem;
 left: 0;
 transition: transform .5s, opacity .5s;
 opacity: 0;
 }

 .hover_link_b:hover {
 color: inherit;
 }

 .hover_link_b:hover::before {
 transform: translateY(-.25rem);
 opacity: 1;
 }
&lt;/style>


&lt;/div></description></item><item><title/><link>https://0125nia.github.io/hide/</link><pubDate>Sat, 08 Feb 2025 17:04:20 +0800</pubDate><guid>https://0125nia.github.io/hide/</guid><description>&lt;a href="https://0125nia.github.io/hide/#Congratulations%20on%20finding%20this%20place%21" style="text-decoration: none;">
 &lt;h1 id="Congratulations on finding this place!" class="bonkers-font" style="font-size: 1.5em;">
 
 Congratulations on finding this place!
 

 &lt;/h1>
&lt;/a>
&lt;p>你可能会觉得你发现了什么不得了的东西&lt;/p>
&lt;p>但实际上这里并没有什么特别的&lt;/p>


&lt;p class="français">
 
 
Vous pouvez penser que vous avez trouvé quelque chose d’extraordinaire.
&lt;br>
Mais il n’y a rien d’extraordinaire ici.

 
&lt;/p>

&lt;style>
 .français {
 font-style: italic;
 font-size: 1.3em;
 font-family: 'Times New Roman', sans-serif;
 line-height: 2;
 }
&lt;/style>







&lt;a href="https://0125nia.github.io/hide/#ABOUT%20ME" style="text-decoration: none;">
 &lt;h1 id="ABOUT ME" class="bonkers-font" style="font-size: 1.5em;">
 
 ABOUT ME
 

 &lt;/h1>
&lt;/a>
&lt;p>As a college student majoring in computer science, I have experience with &lt;strong>Java&lt;/strong>, &lt;strong>Go&lt;/strong>, &lt;strong>C&lt;/strong>, &lt;strong>C++&lt;/strong>, and &lt;strong>Rust&lt;/strong>. Currently, I prefer coding with &lt;strong>Go&lt;/strong> and &lt;strong>Rust&lt;/strong>.&lt;/p></description></item><item><title>Go_study</title><link>https://0125nia.github.io/hide/go_study/</link><pubDate>Sat, 08 Feb 2025 16:28:20 +0800</pubDate><guid>https://0125nia.github.io/hide/go_study/</guid><description>&lt;p>&lt;a href="https://go.dev/tour/welcome/1">https://go.dev/tour/welcome/1&lt;/a>&lt;/p></description></item><item><title>Rust_study</title><link>https://0125nia.github.io/hide/rust_study/</link><pubDate>Sat, 08 Feb 2025 16:28:20 +0800</pubDate><guid>https://0125nia.github.io/hide/rust_study/</guid><description>&lt;blockquote>
&lt;p>&lt;em>A language empowering everyone to build reliable and efficient software.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;h3 id="入门">入门&lt;/h3>
&lt;p>&lt;div style="display: inline-block; padding: 10px;">
 
 
 
 
 

 
 &lt;a href=" https://course.rs/about-book.html" target="_blank">
 &lt;img src="https://0125nia.github.io/img/hide/rs-study/banner.jpg"
 style="width: 300px; height: 150px; object-fit: cover; border-radius: 10px;">
 &lt;/a>
 
 
 &lt;p style="text-align: center; margin-top: 5px; font-size: 14px;">Rust 语言圣经(Rust Course)&lt;/p>
 
&lt;/div>
&lt;div style="display: inline-block; padding: 10px;">
 
 
 
 
 

 
 &lt;a href=" https://github.com/rust-boom/rust-boom" target="_blank">
 &lt;img src="https://0125nia.github.io/img/hide/rs-study/rust_boom.jpg"
 style="width: 300px; height: 150px; object-fit: cover; border-radius: 10px;">
 &lt;/a>
 
 
 &lt;p style="text-align: center; margin-top: 5px; font-size: 14px;">Rust Boom&lt;/p>
 
&lt;/div>
&lt;div style="display: inline-block; padding: 10px;">
 
 
 
 
 

 
 &lt;a href=" https://kaisery.github.io/trpl-zh-cn/foreword.html" target="_blank">
 &lt;img src="https://0125nia.github.io/img/hide/rs-study/cd_home.jpg"
 style="width: 300px; height: 150px; object-fit: cover; border-radius: 10px;">
 &lt;/a>
 
 
 &lt;p style="text-align: center; margin-top: 5px; font-size: 14px;">Rust 程序设计语言 简体中文版&lt;/p>
 
&lt;/div>
&lt;div style="display: inline-block; padding: 10px;">
 
 
 
 
 

 
 &lt;a href=" https://teach-rs.trifectatech.org/" target="_blank">
 &lt;img src="https://0125nia.github.io/img/hide/rs-study/teach-rs.png"
 style="width: 300px; height: 150px; object-fit: cover; border-radius: 10px;">
 &lt;/a>
 
 
 &lt;p style="text-align: center; margin-top: 5px; font-size: 14px;">teach rs&lt;/p></description></item><item><title>Collect</title><link>https://0125nia.github.io/hide/collect/</link><pubDate>Sat, 08 Feb 2025 13:43:15 +0800</pubDate><guid>https://0125nia.github.io/hide/collect/</guid><description>&lt;blockquote>
&lt;p>There will be links of tools and websites.
It might get a little messy.
If I am free, I will sort them out and write some brief introduction for them.&lt;/p>
&lt;/blockquote>
&lt;h1 id="amusant">Amusant&lt;/h1>
&lt;p>Here are some fascinating things.
I find them very enjoyable and relaxing to use.&lt;/p>
&lt;h3 id="icon-or-images">icon or images&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://shields.io">shields&lt;/a>&lt;/p>
&lt;p>Concise, consistent, and legible badges&lt;/p>
&lt;p>&lt;img src="https://img.shields.io/badge/ubuntu-22.04-red?style=flat" alt="Static Badge">&lt;/p>
&lt;p>&lt;img src="https://img.shields.io/badge/go-1.22.5-blue?style=flat" alt="Static Badge">&lt;/p>
&lt;p>&lt;img src="https://0125nia.github.io/img/hide/shields.io.png" alt="shields">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://carbon.now.sh/">carbon&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://feathericons.com">feathericons&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://icon-icons.com">icon-icons&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="fonts">fonts&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://befonts.com/">befonts&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="study">study&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://app.codecrafters.io/">codecrafters&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://www.duolingo.cn/">duolingo&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://adventofcode.com/">adventofcode&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://wangchujiang.com/linux-command/">linux-command&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.khanacademy.org/computing/computer-programming">khanacademy&lt;/a>&lt;/p></description></item><item><title>关于过度开发的思考</title><link>https://0125nia.github.io/posts/excessive_development/</link><pubDate>Wed, 25 Dec 2024 23:54:24 +0800</pubDate><guid>https://0125nia.github.io/posts/excessive_development/</guid><description>&lt;ul>
&lt;li>数据结构和算法 ——应对——&amp;gt; 大数据量问题&lt;/li>
&lt;li>设计模式和代码设计 ——应对——&amp;gt; 复杂代码问题&lt;/li>
&lt;/ul>
&lt;h3 id="避免过度设计">避免过度设计&lt;/h3>
&lt;ul>
&lt;li>不要为了炫技而使用设计模式 不要为了应用而应用 学习阶段的练习除外&lt;/li>
&lt;li>不以破坏代码可读性为前提&lt;/li>
&lt;li>不要为了短期不存在的扩展而费神&lt;/li>
&lt;li>持续重构优于提前设计，一开始就追求完美代码往往不会得到预期的结果&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>YAGNI(You Aren&amp;rsquo;t Gonna Need It)原则
极限编程（XP）中的一项核心实践，它告诫开发者只实现当前需要的功能，避免过度设计和提前优化。这个原则帮助团队集中精力解决实际问题，而不是预测未来可能的需求。&lt;/p>
&lt;/blockquote></description></item><item><title>调度策略 SJF、STCF 与 RR</title><link>https://0125nia.github.io/posts/dispatch/</link><pubDate>Tue, 24 Dec 2024 23:32:03 +0800</pubDate><guid>https://0125nia.github.io/posts/dispatch/</guid><description>&lt;h3 id="周转时间和响应时间">周转时间和响应时间&lt;/h3>
&lt;p>首先我们明确一下两个概念
周转时间与响应时间&lt;/p>
&lt;ul>
&lt;li>
&lt;p>周转时间（Turnaround Time）
一个进程从提交到系统开始执行，到完全完成所花的总时间
是一个进程从开始到结束所经历的总时间，包括等待时间、执行时间和 I/O 操作时间。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>响应时间（Response Time）
一个进程从提交到系统开始运行第一次指令所花的时间
是进程首次获得 CPU 的时间，衡量用户对系统响应的感知速度。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>简单来说&lt;/p>
&lt;p>周转时间就是从任务提交到任务执行完成的时间，是整个任务生命周期的长短&lt;/p>
&lt;p>响应时间就类似，你把任务拿给操作系统，到操作系统开始搭理你，开始执行你的任务的这个等待的时间&lt;/p>
&lt;h3 id="sjfshortest-job-first">SJF(Shortest Job First)&lt;/h3>
&lt;p>最短任务优先代表一个总体调度原则，可以应用于所有重视平均用户周转时间的系统&lt;/p>
&lt;p>考虑到所有工作同时到达的假设，我们可以认为 SJF 确实是一个最优的调度算法&lt;/p>
&lt;p>但仍然有不适用的情况，我们这里引用&lt;a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">OSTEP&lt;/a>的例子&lt;/p>
&lt;p>&lt;img src="https://0125nia.github.io/img/post/dispatch_SJF_flaw.png" alt="SJF_flaw">&lt;/p>
&lt;p>也就是说，如果周转时间为 100s 的 A 任务在 0s 时到达并执行，而当 A 任务执行到 10s 时又有周转时间均为 10s 的 B 任务与 C 任务到达，如果是 SJF 策略的话，B 与 C 需要等待 A 任务执行完毕之后，才开始执行，此时 B 与 C 任务的周转时间就大大提高了，这并不是我们预期的结果&lt;/p>
&lt;h3 id="stcfshortest-time-to-completion-first">STCF(Shortest Time to Completion First)&lt;/h3>
&lt;p>为了解决以上的问题，我们可以允许任务在未执行完时切换到另外的一个周转时间短的任务进行执行
也就是在 SJF 的基础上添加抢占的特性&lt;/p>
&lt;p>STCF 也可称为 PSJF(Preemptive Shortest Job First)&lt;/p></description></item><item><title>Kafka 消费者架构的优化，动态工厂的实践</title><link>https://0125nia.github.io/posts/kafka_consumer/</link><pubDate>Thu, 03 Oct 2024 23:28:13 +0800</pubDate><guid>https://0125nia.github.io/posts/kafka_consumer/</guid><description>&lt;h2 id="为什么使用消费者组">为什么使用消费者组&lt;/h2>
&lt;h4 id="负载均衡">负载均衡&lt;/h4>
&lt;ul>
&lt;li>消费者组机制可以将一个主题的消息负载均衡到多个消费者实例上，提高了整体系统的吞吐量和扩展性&lt;/li>
&lt;li>当有新的消费者加入或退出组时，kafka 都会自动触发平衡机制，确保分区保持合理分配&lt;/li>
&lt;/ul>
&lt;h4 id="状态隔离">状态隔离&lt;/h4>
&lt;ul>
&lt;li>每个消费者组都有自己独立的消费位移（offset），互不干扰，这确保了不同业务场景的状态隔离，提高了系统的可维护性及可靠性&lt;/li>
&lt;li>可针对不同的业务需求，创建独立的消费组，实现更合理或更符合业务需求的状态管理&lt;/li>
&lt;/ul>
&lt;p>通过消费者组，Kafka 可以实现消息的负载均衡和消费者的水平扩展，从而处理大规模的实时数据流和实现高吞吐量的消息处理。&lt;/p>
&lt;h2 id="配置消费者组的传统方式">配置消费者组的传统方式&lt;/h2>
&lt;ol>
&lt;li>在配置文件中硬编码 group-id&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">spring.kafka.consumer.group-id&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">my-group&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>在消费者类中使用 Spring kafka 提供的&lt;code>@KafkaListener&lt;/code>注解:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@KafkaListener&lt;/span>(topic &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;my-topic&amp;#34;&lt;/span>, groupId &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;my-group&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">consume&lt;/span>(String message){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">//处理消息逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此处的&lt;code>groupId&lt;/code>即以上在配置文件中配置的消费者组 id&lt;/p>
&lt;h2 id="存在的问题">存在的问题&lt;/h2>
&lt;ol>
&lt;li>配置方式：在应用程序的配置文件中，需要&lt;strong>手动&lt;/strong>指定 Kafka 消费者组的 id。但当我们需要配置&lt;strong>多个&lt;/strong>消费者组或消费者组的数量无法在应用程序运行前知晓时，此时便陷入了困境。&lt;/li>
&lt;li>扩展性：如果需要动态扩展应用程序的消费者实例数量，又需要我们手动修改配置，增加了复杂度。&lt;/li>
&lt;li>资源竞争：如若我们只使用一个或少量的消费者组，多个应用实例同时使用了相同的消费者消费者组 id，他们可能会争抢同一批分区，可能会导致资源竞争和状态干扰&lt;/li>
&lt;/ol>
&lt;p>Kafka 的消费者组机制是非常重要的组成部分，但其传统的配置方式存在一些局限性，这就需要我们找寻更为灵活可靠的方式来配置多个消费者组。&lt;/p></description></item><item><title>MySQL中的锁</title><link>https://0125nia.github.io/posts/mysql_lock/</link><pubDate>Sat, 17 Aug 2024 16:11:13 +0800</pubDate><guid>https://0125nia.github.io/posts/mysql_lock/</guid><description>&lt;h3 id="全局锁">全局锁&lt;/h3>
&lt;blockquote>
&lt;p>设在多个事务同时访问同一条数据时，冲突发生的概率较低，因此在操作数据时不会立即进行锁定，而是在提交数据更改时检查是否有其它事务修改了这条数据，若没有就提交更改，否则就回滚事务&lt;/p>
&lt;/blockquote>
&lt;p>MYSQL中并没有内置实现乐观锁，但可以通过一些技巧实现，常见的实现方式是使用版本号（或时间戳）字段，每当一条记录被修改时，就增加版本号（或更新时间戳）。
在更新记录时，先检查版本号（或时间戳）是否和读取记录时的版本号（或时间戳）一致，如果一致则执行更新并增加版本号（或更新时间戳），否则拒绝更新&lt;/p>
&lt;p>&lt;strong>优点&lt;/strong>：在大部分时间都不需要锁定，所以在冲突较少的情况下可以获得较高的并发性能，然而，如果冲突较多，那么乐观锁可能会导致大量的事务回滚，从而影响性能，因此，选择乐观锁还是其它锁定技术，需要根据实际的并发情况和性能需求来决定&lt;/p>
&lt;p>&lt;strong>使用场景&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>低冲突环境&lt;/li>
&lt;li>读多写少的场景：在读操作远多于写操作的情况下，乐观锁可以避免由于频繁的读操作导致不必要的锁定开销&lt;/li>
&lt;li>短事务操作&lt;/li>
&lt;li>分布式系统：由于网络延迟等原因，事务冲突的可能性较低，因此乐观锁是一个合适的选择&lt;/li>
&lt;li>互联网应用：并发修改同一条数据的几率较小，因此使用乐观锁可以提高系统性能&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>缺点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>冲突检测&lt;/li>
&lt;li>处理开销：冲突发生时需要进行回滚和重试，可能会增加系统的开销，在一些场景中可能会导致性能下降&lt;/li>
&lt;li>版本管理：乐观锁通常通过版本号（或时间戳）来检测冲突&lt;/li>
&lt;li>编程复杂性：使用乐观锁需要更复杂的编程，程序需要处理可能发生的冲突和重试&lt;/li>
&lt;/ul>
&lt;p>有效的并发控制策略，在冲突较多的情况下可能会带来更大的开销和编程复杂性，因此是否使用乐观锁现需要根据应用的具体需求和场景来决定&lt;/p>
&lt;hr>
&lt;h3 id="表锁">表锁&lt;/h3>
&lt;blockquote>
&lt;p>mysql中最基本的锁策略
表级锁开销小、加锁快，不会出现死锁
锁定粒度大，发生锁冲突的概率最高
并发度最低&lt;/p>
&lt;/blockquote>
&lt;p>表共享读锁(Table Read Lock)：表读锁，允许一个事务锁定的表进行读取操作，不允许其它事务对其进行写操作，但可以进行读操作，读锁之间是不会互相阻塞的&lt;/p>
&lt;p>表独占写锁（Table Write Lock）表写锁 允许一个事务锁定的表进行读取和写入（更新）操作，但其它任何事务都不能再对该表进行任何操作，必须等待表写锁结束，写锁会阻塞其它所有锁，包括读锁和写锁&lt;/p>
&lt;p>在MySQL中对MylSAM表的读操作，会自动加上读锁，对MylSAM表的写操作，会自动加上写锁&lt;/p>
&lt;p>InnoDB引擎在必要的情况下会使用表锁，但主要是使用行锁来实现多版本并发控制（MVCC）能提供更好的并发性能和更少的锁冲突&lt;/p>
&lt;p>适用读操作多，写操作少的应用，当并发争用5不是特别激烈，以及记录级锁并发控制开销大于访问冲突开销的情况，在并发度高，或写操作较多的情况下，表锁可能会成为瓶颈&lt;/p>
&lt;p>&lt;strong>使用场景&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>读密集型&lt;/p>
&lt;/li>
&lt;li>
&lt;p>写操作不频繁的场景&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据量不大的简单应用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>全表更新或删除&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>虽然表级锁的开销小，但由于其锁定粒度大，可能会导致并发度下降&lt;/p>
&lt;p>MYSQL中会发生表级锁的命令&lt;/p>
&lt;ul>
&lt;li>&lt;code>ALTER TABLE&lt;/code>&lt;/li>
&lt;li>&lt;code>DROP TABLE&lt;/code> &amp;amp; &lt;code>TRUNCATE TABLE&lt;/code> 删除整个表以及删除表中的所有数据&lt;/li>
&lt;li>&lt;code>LOCK TABLES&lt;/code>&lt;/li>
&lt;li>MYlSAM存储引擎，全表扫描或大范围扫描&lt;/li>
&lt;li>全局锁&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>表锁的风险点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>性能下降：在高并发的环境中可能导致大量的请求阻塞，从而降低性能，对于读取和写入混合密集的负载，表锁可能会成为一个性能瓶颈&lt;/li>
&lt;li>并发性能差：一旦一个线程对表加了写锁，其它线程的任何读写操作都会被阻塞，直到写锁被释放，同样的，如果一个读锁被持有，那么其它的写操作将被阻塞，这就使得并发性能大大降低&lt;/li>
&lt;li>可能导致锁等待和超时：在高并发的环境中，由于表级锁的粒度较大，可能会有很多线程在等待锁，如果等待的时间过长，可能会导致锁超时，进一步影响应用的性能和可用性&lt;/li>
&lt;li>写操作影响大&lt;/li>
&lt;li>死锁的可能性：表锁本身不会出现死锁，但在多表操作中，若没有按照一定的顺序获得锁，可能会导致读锁&lt;/li>
&lt;/ul>
&lt;p>为避免此类问题，通常会选择InnoDB存储引擎，主要使用行级锁，可提供更好的并发性能，并在一定程度上减少锁争用的问题
并且InnoDB支持事务，可保证数据的一致性和完整性，在实际应用中，我们应根据具体的业务需求和系统负载，选择合适的存储引擎和锁策略&lt;/p>
&lt;hr>
&lt;h3 id="行锁">行锁&lt;/h3>
&lt;blockquote>
&lt;p>单表中单行进行锁定&lt;/p>
&lt;/blockquote>
&lt;p>相比于表级锁和页锁，行级锁的粒度更小，因此在处理高并发事务时，能提供更好的并发性能和更少的锁冲突，然而，行级锁也需要更多的内存和CPU资源，需要对每一行都进行管理&lt;/p>
&lt;p>在MYSQL中行级锁主要有InnoDB提供，InnoDB支持两种类型的行级锁&lt;/p>
&lt;ul>
&lt;li>共享锁（S锁）读锁&lt;/li>
&lt;li>排他锁（X锁）写锁&lt;/li>
&lt;/ul>
&lt;p>在实际应用中InnoDB还提供了一种间隙锁的特性，不仅锁定一个具体的行，还锁定其前后的间隙，可以防止其它事务插入新的行到已锁定行的前后，从而解决一些并发问题&lt;/p>
&lt;p>&lt;strong>使用场景&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>高并发读写操作&lt;/li>
&lt;li>单行操作&lt;/li>
&lt;li>短期锁&lt;/li>
&lt;li>实现并发控制&lt;/li>
&lt;li>复杂的事务处理&lt;/li>
&lt;/ul>
&lt;p>由于行级锁的锁定粒度较小，可能消耗更多的系统资源（例如内存和CPU），特别是在处理大量数据时，此外使用行级锁也可能导致死锁，需要使用合适的策略来避免死锁，例如在事务中按照一定的顺序锁定行&lt;/p></description></item><item><title>快速入门Cobra - 强大的Go语言命令行构建框架</title><link>https://0125nia.github.io/posts/cobra/</link><pubDate>Fri, 03 May 2024 23:16:15 +0800</pubDate><guid>https://0125nia.github.io/posts/cobra/</guid><description>&lt;h3 id="cobra-介绍">Cobra 介绍&lt;/h3>
&lt;p>Cobra 是一个 Go 语言开发的命令行（CLI）框架，提供了简单的接口来构建命令行界面，Cobra 允许轻松地定义命令和子命令结构。被用在很多 Go 语言的项目中，比如我们熟知的 K8s、Docker 等等&lt;/p>
&lt;p>Cobra 在我的项目中作为命令行解析层，接触到这个命令行框架，了解到 Cobra 的强大功能，故在此进行记录&lt;/p>
&lt;p>附上 Cobra 的&lt;a href="https://github.com/spf13/cobra">项目地址&lt;/a>以及&lt;a href="https://cobra.dev">开发网站&lt;/a>&lt;/p>
&lt;h3 id="cobra-概念">Cobra 概念&lt;/h3>
&lt;p>Cobra 是基于命令 &lt;code>commands&lt;/code> 、参数 &lt;code>arguments&lt;/code> 、选项 &lt;code>flags&lt;/code> 三个部分构建的&lt;/p>
&lt;p>要遵循的模式是 &lt;code>APPNAME VERB NOUN --ADJECTIVE.&lt;/code> 或 &lt;code>APPNAME COMMAND ARG --FLAG&lt;/code>&lt;/p>
&lt;p>（&lt;em>应用名称 动词 名词 &amp;ndash;形容词&lt;/em> 或 &lt;em>应用名称 命令 参数 &amp;ndash;标志&lt;/em>）&lt;/p>
&lt;h5 id="appname">appname&lt;/h5>
&lt;p>应用程序的名称，标识要运行的程序或工具。例如，&lt;code>git&lt;/code>、&lt;code>curl&lt;/code>、&lt;code>docker&lt;/code>等&lt;/p>
&lt;h5 id="commands">commands&lt;/h5>
&lt;p>描述了要执行的操作类型。它通常代表了一个功能或者动作，在某些 CLI 设计中，这部分可能直接就是一个具体操作的名称，如&lt;code>pull&lt;/code>、&lt;code>push&lt;/code>。&lt;/p>
&lt;h5 id="arguments">arguments&lt;/h5>
&lt;p>名词或参数，提供了动词作用的对象或者是更具体的上下文信息。例如：&lt;code>go build main.go&lt;/code>,
这个命令的&lt;code>go&lt;/code>是应用程序名称（appname），&lt;code>build&lt;/code>是操作类型（commands），而&lt;code>main.go&lt;/code>就是&lt;code>build&lt;/code>作用的对象&lt;/p>
&lt;h5 id="flags">flags&lt;/h5>
&lt;p>命令行标志或选项，用来修改命令的行为或提供额外的配置信息。通常以两个连字符&lt;code>--&lt;/code>开头，后面跟着标志名称。在某些情况下，如短选项，也可能只有一个连字符和一个字母&lt;/p>
&lt;p>&lt;strong>示例：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>git commit -m &amp;quot;Initial commit&amp;quot;&lt;/code>：这里&lt;code>git&lt;/code>是应用程序名称，&lt;code>commit&lt;/code>是命令，&lt;code>-m&lt;/code>是一个标志，后面跟着的 &lt;code>&amp;quot;Initial commit&amp;quot;&lt;/code> 是该标志的值，作为提交信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>hugo server --port=1313&lt;/code>：&lt;code>hugo&lt;/code>为应用程序名称，&lt;code>server&lt;/code>是命令，&lt;code>port&lt;/code>是标志&lt;/p></description></item><item><title>网络编程 - BIO、NIO</title><link>https://0125nia.github.io/posts/network_program/</link><pubDate>Mon, 10 Jul 2023 18:44:43 +0800</pubDate><guid>https://0125nia.github.io/posts/network_program/</guid><description>&lt;blockquote>
&lt;p>网络编程是指利用计算机网络进行数据交换和通信的编程技术，使得不同计算机或设备之间能通过网络进行信息传输&lt;/p>
&lt;/blockquote>
&lt;h3 id="基础概念">基础概念&lt;/h3>
&lt;p>首先了解一下网络编程的基础概念&lt;/p>
&lt;h4 id="客户端和服务器">客户端和服务器&lt;/h4>
&lt;ul>
&lt;li>客户端是指发起请求的一方，一般是属于用户端的设备，例如浏览器、手机应用&lt;/li>
&lt;li>服务器是接收并处理请求的一方，负责提供服务或资源，例如web服务器、数据库等&lt;/li>
&lt;/ul>
&lt;h4 id="套接字-socket">套接字 socket&lt;/h4>
&lt;p>套接字是网络编程中的核心，提供了一个通信端点，客户端和服务器通过套接字进行数据的传输&lt;/p>
&lt;p>套接字的主要作用是实现对网络通信的封装，包括数据的发送和接收&lt;/p>
&lt;h4 id="协议">协议&lt;/h4>
&lt;p>协议是指一套规则和约定，用来规范网络中通信双方如何交换数据。协议定义了数据的格式、传输的顺序、错误处理机制、重传机制等。&lt;/p>
&lt;p>常见通信协议有 TCP/IP、UDP&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>TCP（传输控制协议）&lt;/strong>：面向连接，可靠，保证数据的顺序和完整性。适用于要求数据传输准确、稳定的应用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>UDP（用户数据报协议）&lt;/strong>：无连接，不可靠，传输速度快，适用于实时应用，如视频、语音通话等。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="网络编程的主要步骤">网络编程的主要步骤&lt;/h3>
&lt;ol>
&lt;li>创建套接字&lt;/li>
&lt;li>在服务器端绑定地址&lt;/li>
&lt;li>在服务器端监听和接受连接&lt;/li>
&lt;li>客户端连接到服务端&lt;/li>
&lt;li>数据传输&lt;/li>
&lt;li>关闭连接&lt;/li>
&lt;/ol>
&lt;h3 id="网络演变的本质">网络演变的本质&lt;/h3>
&lt;p>随着网络连接上升，为了解决连接的问题而产生的变化&lt;/p>
&lt;h3 id="阻塞io">阻塞IO&lt;/h3>
&lt;blockquote>
&lt;p>即BIO&lt;/p>
&lt;/blockquote>
&lt;p>在输入/输出操作时，程序会被阻塞，直到操作完成，在阻塞IO模式下，当程序请求读取或写入数据时，程序会暂停执行，等待操作完成后才会继续执行&lt;/p>
&lt;p>优点很明显，可以简单实现client和server端的通信 通常一个client连接分配一个线程进行处理&lt;/p>
&lt;p>但缺点是 能支持的并发client连接数较少，一台server能分配的线程是有限的，大量线程会造成上下文切换过多而影响性能&lt;/p>
&lt;hr>
&lt;p>为了解决以上问题，避免阻塞影响后续接收新的client连接，需将阻塞逻辑交由&lt;strong>单独线程&lt;/strong>进行处理&lt;/p>
&lt;h3 id="非阻塞io">非阻塞IO&lt;/h3>
&lt;blockquote>
&lt;p>NIO&lt;/p>
&lt;/blockquote>
&lt;p>在进行 I/O 操作时，程序不会因等待数据的传输阻塞，操作会立即返回，程序可以继续执行其他任务，直到有数据可以读取或写入时再进行操作&lt;/p>
&lt;p>相比于阻塞 I/O，非阻塞 I/O 可以显著提高程序的响应性和并发性&lt;/p>
&lt;p>优点是比较明显的，服务器在读取时数据未就绪就直接返回，无需阻塞，可以通过一个线程来管理多个client连接&lt;/p>
&lt;p>而缺点是 由于系统并不知道数据何时准备就绪，需要不断的进行&lt;strong>轮询&lt;/strong>，涉及很多无效的、频繁的系统调用&lt;/p>
&lt;hr>
&lt;p>而对非阻塞IO轮询可以如何改进呢？将会在后续进行补充&lt;/p></description></item><item><title>Echo Dispatch</title><link>https://0125nia.github.io/projects/echo_dispatch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://0125nia.github.io/projects/echo_dispatch/</guid><description>&lt;blockquote>
&lt;p>通过内嵌SDK的方式接入短信、邮箱等渠道实现统一的接口发送各种类型消息，记录消息的发送情况，对消息生命周期全链路追踪。使用消费组实现消息资源的隔离，不同的渠道中的不同消息类型互不影响。&lt;/p>
&lt;/blockquote></description></item><item><title>Find Me</title><link>https://0125nia.github.io/projects/find_me/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://0125nia.github.io/projects/find_me/</guid><description>&lt;blockquote>
&lt;p>一个帮助用户了解自我、认识自我、完善自我的“自我成长类平台”，旨在为用户提供自我探索、职业测试、星星交流区、匹配交流、成长星球、职业学习路线推荐、ToBingo计划等服务，一站式满足多样化的自我成长需求&lt;/p>
&lt;/blockquote></description></item><item><title>Interpreter for lox</title><link>https://0125nia.github.io/projects/interpreter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://0125nia.github.io/projects/interpreter/</guid><description>&lt;blockquote>
&lt;p>一个使用Rust编写的lox语言解释器&lt;/p>
&lt;/blockquote>
&lt;p>待续&amp;hellip;&lt;/p></description></item><item><title>Mercury</title><link>https://0125nia.github.io/projects/mercury/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://0125nia.github.io/projects/mercury/</guid><description>&lt;blockquote>
&lt;p>手写的im系统，目标是能够处理百亿级消息量
自研网关及ipconfig，作为im系统的接入层&lt;/p>
&lt;/blockquote></description></item><item><title>mit6.5840</title><link>https://0125nia.github.io/projects/mit65840/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://0125nia.github.io/projects/mit65840/</guid><description>&lt;blockquote>
&lt;p>MIT6.5840(MIT 6.824) 是麻省理工学院（MIT）开设的一门分布式系统（Distributed Systems）课程&lt;/p>
&lt;/blockquote></description></item></channel></rss>