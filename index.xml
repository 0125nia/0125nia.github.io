<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>nia</title><link>https://0125nia.github.io/</link><description>Recent content on nia</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 08 Feb 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://0125nia.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Nav</title><link>https://0125nia.github.io/hide/nav/</link><pubDate>Sat, 08 Feb 2025 18:52:50 +0800</pubDate><guid>https://0125nia.github.io/hide/nav/</guid><description>&lt;p>&lt;a href="./../collect">collect&lt;/a>&lt;/p>
&lt;p>&lt;a href="./../rust_study">rust_study&lt;/a>&lt;/p></description></item><item><title>Congratulations on finding this place!</title><link>https://0125nia.github.io/hide/</link><pubDate>Sat, 08 Feb 2025 17:04:20 +0800</pubDate><guid>https://0125nia.github.io/hide/</guid><description>&lt;p>你可能会觉得你发现了什么不得了的东西&lt;/p>
&lt;p>但实际上这里并没有什么特别的&lt;/p>
&lt;p>Vous pouvez penser que vous avez trouvé quelque chose d’extraordinaire&lt;/p>
&lt;p>Mais il n’y a rien d’extraordinaire ici&lt;/p>
&lt;h1 id="about-me">ABOUT ME&lt;/h1>
&lt;p>As a college student majoring in computer science, I have experience with Java, Go, C, C++, and Rust. Currently, I prefer coding with Go and Rust.&lt;/p>
&lt;p>I am working on improving my English skills and still trying to use English whenever possible. Additionally, I am learning French.&lt;/p>
&lt;p>My goal is to enhance my English proficiency and perfect this blog.&lt;/p></description></item><item><title>Rust_study</title><link>https://0125nia.github.io/hide/rust_study/</link><pubDate>Sat, 08 Feb 2025 16:28:20 +0800</pubDate><guid>https://0125nia.github.io/hide/rust_study/</guid><description>&lt;blockquote>
&lt;p>&lt;em>A language empowering everyone to build reliable and efficient software.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;h3 id="入门">入门&lt;/h3>
&lt;p>&lt;div style="display: inline-block; padding: 10px;">
 
 
 
 
 

 
 &lt;a href=" https://course.rs/about-book.html" target="_blank">
 &lt;img src="https://0125nia.github.io/img/hide/rs-study/banner.jpg"
 style="width: 300px; height: 150px; object-fit: cover; border-radius: 10px;">
 &lt;/a>
 
 
 &lt;p style="text-align: center; margin-top: 5px; font-size: 14px;">Rust 语言圣经(Rust Course)&lt;/p>
 
&lt;/div>
&lt;div style="display: inline-block; padding: 10px;">
 
 
 
 
 

 
 &lt;a href=" https://kaisery.github.io/trpl-zh-cn/foreword.html" target="_blank">
 &lt;img src="https://0125nia.github.io/img/hide/rs-study/cd_home.jpg"
 style="width: 300px; height: 150px; object-fit: cover; border-radius: 10px;">
 &lt;/a>
 
 
 &lt;p style="text-align: center; margin-top: 5px; font-size: 14px;">Rust 程序设计语言 简体中文版&lt;/p>
 
&lt;/div>&lt;/p>
&lt;div style="display: inline-block; padding: 10px;">
 
 
 
 
 

 
 &lt;a href=" https://teach-rs.trifectatech.org/" target="_blank">
 &lt;img src="https://0125nia.github.io/img/hide/rs-study/teach-rs.png"
 style="width: 300px; height: 150px; object-fit: cover; border-radius: 10px;">
 &lt;/a>
 
 
 &lt;p style="text-align: center; margin-top: 5px; font-size: 14px;">teach rs&lt;/p>
 
&lt;/div>
&lt;div style="display: inline-block; padding: 10px;">
 
 
 
 
 

 
 &lt;a href=" https://github.com/rust-boom/rust-boom" target="_blank">
 &lt;img src="https://0125nia.github.io/img/hide/rs-study/rust_boom.jpg"
 style="width: 300px; height: 150px; object-fit: cover; border-radius: 10px;">
 &lt;/a>
 
 
 &lt;p style="text-align: center; margin-top: 5px; font-size: 14px;">Rust Boom&lt;/p></description></item><item><title>Collect</title><link>https://0125nia.github.io/hide/collect/</link><pubDate>Sat, 08 Feb 2025 13:43:15 +0800</pubDate><guid>https://0125nia.github.io/hide/collect/</guid><description>&lt;p>&lt;em>Man is a tool using animal. Without tools, he is nothing. With tools, he is all.&lt;/em>&lt;/p>
&lt;blockquote>
&lt;p>There will be links of tools and websites.
It might get a little messy.
If I am free, I will sort them out and write some brief introduction for them.&lt;/p>
&lt;/blockquote>
&lt;h1 id="amusant">Amusant&lt;/h1>
&lt;p>Here are some fascinating things.
I find them very enjoyable and relaxing to use.&lt;/p>
&lt;h3 id="icon-or-images">icon or images&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://shields.io">shields&lt;/a>&lt;/p>
&lt;p>Concise, consistent, and legible badges&lt;/p></description></item><item><title>关于过度开发的思考</title><link>https://0125nia.github.io/posts/excessive_development/</link><pubDate>Wed, 25 Dec 2024 23:54:24 +0800</pubDate><guid>https://0125nia.github.io/posts/excessive_development/</guid><description>&lt;ul>
&lt;li>数据结构和算法 ——应对——&amp;gt; 大数据量问题&lt;/li>
&lt;li>设计模式和代码设计 ——应对——&amp;gt; 复杂代码问题&lt;/li>
&lt;/ul>
&lt;h3 id="避免过度设计">避免过度设计&lt;/h3>
&lt;ul>
&lt;li>不要为了炫技而使用设计模式 不要为了应用而应用 学习阶段的练习除外&lt;/li>
&lt;li>不以破坏代码可读性为前提&lt;/li>
&lt;li>不要为了短期不存在的扩展而费神&lt;/li>
&lt;li>持续重构优于提前设计，一开始就追求完美代码往往不会得到预期的结果&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>YAGNI(You Aren&amp;rsquo;t Gonna Need It)原则
极限编程（XP）中的一项核心实践，它告诫开发者只实现当前需要的功能，避免过度设计和提前优化。这个原则帮助团队集中精力解决实际问题，而不是预测未来可能的需求。&lt;/p>
&lt;/blockquote></description></item><item><title>调度策略 SJF、STCF 与 RR</title><link>https://0125nia.github.io/posts/dispatch/</link><pubDate>Tue, 24 Dec 2024 23:32:03 +0800</pubDate><guid>https://0125nia.github.io/posts/dispatch/</guid><description>&lt;h3 id="周转时间和响应时间">周转时间和响应时间&lt;/h3>
&lt;p>首先我们明确一下两个概念
周转时间与响应时间&lt;/p>
&lt;ul>
&lt;li>
&lt;p>周转时间（Turnaround Time）
一个进程从提交到系统开始执行，到完全完成所花的总时间
是一个进程从开始到结束所经历的总时间，包括等待时间、执行时间和 I/O 操作时间。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>响应时间（Response Time）
一个进程从提交到系统开始运行第一次指令所花的时间
是进程首次获得 CPU 的时间，衡量用户对系统响应的感知速度。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>简单来说&lt;/p>
&lt;p>周转时间就是从任务提交到任务执行完成的时间，是整个任务生命周期的长短&lt;/p>
&lt;p>响应时间就类似，你把任务拿给操作系统，到操作系统开始搭理你，开始执行你的任务的这个等待的时间&lt;/p>
&lt;h3 id="sjfshortest-job-first">SJF(Shortest Job First)&lt;/h3>
&lt;p>最短任务优先代表一个总体调度原则，可以应用于所有重视平均用户周转时间的系统&lt;/p>
&lt;p>考虑到所有工作同时到达的假设，我们可以认为 SJF 确实是一个最优的调度算法&lt;/p>
&lt;p>但仍然有不适用的情况，我们这里引用&lt;a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">OSTEP&lt;/a>的例子&lt;/p>
&lt;p>&lt;img src="https://0125nia.github.io/img/post/dispatch_SJF_flaw.png" alt="SJF_flaw">&lt;/p>
&lt;p>也就是说，如果周转时间为 100s 的 A 任务在 0s 时到达并执行，而当 A 任务执行到 10s 时又有周转时间均为 10s 的 B 任务与 C 任务到达，如果是 SJF 策略的话，B 与 C 需要等待 A 任务执行完毕之后，才开始执行，此时 B 与 C 任务的周转时间就大大提高了，这并不是我们预期的结果&lt;/p>
&lt;h3 id="stcfshortest-time-to-completion-first">STCF(Shortest Time to Completion First)&lt;/h3>
&lt;p>为了解决以上的问题，我们可以允许任务在未执行完时切换到另外的一个周转时间短的任务进行执行
也就是在 SJF 的基础上添加抢占的特性&lt;/p>
&lt;p>STCF 也可称为 PSJF(Preemptive Shortest Job First)&lt;/p></description></item><item><title>Kafka 消费者架构的优化，动态工厂的实践</title><link>https://0125nia.github.io/posts/kafka_consumer/</link><pubDate>Thu, 03 Oct 2024 23:28:13 +0800</pubDate><guid>https://0125nia.github.io/posts/kafka_consumer/</guid><description>&lt;h2 id="为什么使用消费者组">为什么使用消费者组&lt;/h2>
&lt;h4 id="负载均衡">负载均衡&lt;/h4>
&lt;ul>
&lt;li>消费者组机制可以将一个主题的消息负载均衡到多个消费者实例上，提高了整体系统的吞吐量和扩展性&lt;/li>
&lt;li>当有新的消费者加入或退出组时，kafka 都会自动触发平衡机制，确保分区保持合理分配&lt;/li>
&lt;/ul>
&lt;h4 id="状态隔离">状态隔离&lt;/h4>
&lt;ul>
&lt;li>每个消费者组都有自己独立的消费位移（offset），互不干扰，这确保了不同业务场景的状态隔离，提高了系统的可维护性及可靠性&lt;/li>
&lt;li>可针对不同的业务需求，创建独立的消费组，实现更合理或更符合业务需求的状态管理&lt;/li>
&lt;/ul>
&lt;p>通过消费者组，Kafka 可以实现消息的负载均衡和消费者的水平扩展，从而处理大规模的实时数据流和实现高吞吐量的消息处理。&lt;/p>
&lt;h2 id="配置消费者组的传统方式">配置消费者组的传统方式&lt;/h2>
&lt;ol>
&lt;li>在配置文件中硬编码 group-id&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">spring.kafka.consumer.group-id&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">my-group&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>在消费者类中使用 Spring kafka 提供的&lt;code>@KafkaListener&lt;/code>注解:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@KafkaListener&lt;/span>(topic &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;my-topic&amp;#34;&lt;/span>, groupId &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;my-group&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">consume&lt;/span>(String message){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">//处理消息逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此处的&lt;code>groupId&lt;/code>即以上在配置文件中配置的消费者组 id&lt;/p>
&lt;h2 id="存在的问题">存在的问题&lt;/h2>
&lt;ol>
&lt;li>配置方式：在应用程序的配置文件中，需要&lt;strong>手动&lt;/strong>指定 Kafka 消费者组的 id。但当我们需要配置&lt;strong>多个&lt;/strong>消费者组或消费者组的数量无法在应用程序运行前知晓时，此时便陷入了困境。&lt;/li>
&lt;li>扩展性：如果需要动态扩展应用程序的消费者实例数量，又需要我们手动修改配置，增加了复杂度。&lt;/li>
&lt;li>资源竞争：如若我们只使用一个或少量的消费者组，多个应用实例同时使用了相同的消费者消费者组 id，他们可能会争抢同一批分区，可能会导致资源竞争和状态干扰&lt;/li>
&lt;/ol>
&lt;p>Kafka 的消费者组机制是非常重要的组成部分，但其传统的配置方式存在一些局限性，这就需要我们找寻更为灵活可靠的方式来配置多个消费者组。&lt;/p></description></item><item><title>快速入门Cobra - 强大的Go语言命令行构建框架</title><link>https://0125nia.github.io/posts/cobra/</link><pubDate>Fri, 03 May 2024 23:16:15 +0800</pubDate><guid>https://0125nia.github.io/posts/cobra/</guid><description>&lt;h3 id="cobra-介绍">Cobra 介绍&lt;/h3>
&lt;p>Cobra 是一个 Go 语言开发的命令行（CLI）框架，提供了简单的接口来构建命令行界面，Cobra 允许轻松地定义命令和子命令结构。被用在很多 Go 语言的项目中，比如我们熟知的 K8s、Docker 等等&lt;/p>
&lt;p>Cobra 在我的项目中作为命令行解析层，接触到这个命令行框架，了解到 Cobra 的强大功能，故在此进行记录&lt;/p>
&lt;p>附上 Cobra 的&lt;a href="https://github.com/spf13/cobra">项目地址&lt;/a>以及&lt;a href="https://cobra.dev">开发网站&lt;/a>&lt;/p>
&lt;h3 id="cobra-概念">Cobra 概念&lt;/h3>
&lt;p>Cobra 是基于命令 &lt;code>commands&lt;/code> 、参数 &lt;code>arguments&lt;/code> 、选项 &lt;code>flags&lt;/code> 三个部分构建的&lt;/p>
&lt;p>要遵循的模式是 &lt;code>APPNAME VERB NOUN --ADJECTIVE.&lt;/code> 或 &lt;code>APPNAME COMMAND ARG --FLAG&lt;/code>&lt;/p>
&lt;p>（&lt;em>应用名称 动词 名词 &amp;ndash;形容词&lt;/em> 或 &lt;em>应用名称 命令 参数 &amp;ndash;标志&lt;/em>）&lt;/p>
&lt;h5 id="appname">appname&lt;/h5>
&lt;p>应用程序的名称，标识要运行的程序或工具。例如，&lt;code>git&lt;/code>、&lt;code>curl&lt;/code>、&lt;code>docker&lt;/code>等&lt;/p>
&lt;h5 id="commands">commands&lt;/h5>
&lt;p>描述了要执行的操作类型。它通常代表了一个功能或者动作，在某些 CLI 设计中，这部分可能直接就是一个具体操作的名称，如&lt;code>pull&lt;/code>、&lt;code>push&lt;/code>。&lt;/p>
&lt;h5 id="arguments">arguments&lt;/h5>
&lt;p>名词或参数，提供了动词作用的对象或者是更具体的上下文信息。例如：&lt;code>go build main.go&lt;/code>,
这个命令的&lt;code>go&lt;/code>是应用程序名称（appname），&lt;code>build&lt;/code>是操作类型（commands），而&lt;code>main.go&lt;/code>就是&lt;code>build&lt;/code>作用的对象&lt;/p>
&lt;h5 id="flags">flags&lt;/h5>
&lt;p>命令行标志或选项，用来修改命令的行为或提供额外的配置信息。通常以两个连字符&lt;code>--&lt;/code>开头，后面跟着标志名称。在某些情况下，如短选项，也可能只有一个连字符和一个字母&lt;/p>
&lt;p>&lt;strong>示例：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>git commit -m &amp;quot;Initial commit&amp;quot;&lt;/code>：这里&lt;code>git&lt;/code>是应用程序名称，&lt;code>commit&lt;/code>是命令，&lt;code>-m&lt;/code>是一个标志，后面跟着的 &lt;code>&amp;quot;Initial commit&amp;quot;&lt;/code> 是该标志的值，作为提交信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>hugo server --port=1313&lt;/code>：&lt;code>hugo&lt;/code>为应用程序名称，&lt;code>server&lt;/code>是命令，&lt;code>port&lt;/code>是标志&lt;/p></description></item></channel></rss>