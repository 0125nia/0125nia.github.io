<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Os on nia</title><link>https://0125nia.github.io/tags/os/</link><description>Recent content in Os on nia</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 08 Feb 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://0125nia.github.io/tags/os/index.xml" rel="self" type="application/rss+xml"/><item><title>调度策略 SJF、STCF 与 RR</title><link>https://0125nia.github.io/posts/dispatch/</link><pubDate>Tue, 24 Dec 2024 23:32:03 +0800</pubDate><guid>https://0125nia.github.io/posts/dispatch/</guid><description>&lt;h3 id="周转时间和响应时间">周转时间和响应时间&lt;/h3>
&lt;p>首先我们明确一下两个概念
周转时间与响应时间&lt;/p>
&lt;ul>
&lt;li>
&lt;p>周转时间（Turnaround Time）
一个进程从提交到系统开始执行，到完全完成所花的总时间
是一个进程从开始到结束所经历的总时间，包括等待时间、执行时间和 I/O 操作时间。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>响应时间（Response Time）
一个进程从提交到系统开始运行第一次指令所花的时间
是进程首次获得 CPU 的时间，衡量用户对系统响应的感知速度。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>简单来说&lt;/p>
&lt;p>周转时间就是从任务提交到任务执行完成的时间，是整个任务生命周期的长短&lt;/p>
&lt;p>响应时间就类似，你把任务拿给操作系统，到操作系统开始搭理你，开始执行你的任务的这个等待的时间&lt;/p>
&lt;h3 id="sjfshortest-job-first">SJF(Shortest Job First)&lt;/h3>
&lt;p>最短任务优先代表一个总体调度原则，可以应用于所有重视平均用户周转时间的系统&lt;/p>
&lt;p>考虑到所有工作同时到达的假设，我们可以认为 SJF 确实是一个最优的调度算法&lt;/p>
&lt;p>但仍然有不适用的情况，我们这里引用&lt;a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">OSTEP&lt;/a>的例子&lt;/p>
&lt;p>&lt;img src="https://0125nia.github.io/img/post/dispatch_SJF_flaw.png" alt="SJF_flaw">&lt;/p>
&lt;p>也就是说，如果周转时间为 100s 的 A 任务在 0s 时到达并执行，而当 A 任务执行到 10s 时又有周转时间均为 10s 的 B 任务与 C 任务到达，如果是 SJF 策略的话，B 与 C 需要等待 A 任务执行完毕之后，才开始执行，此时 B 与 C 任务的周转时间就大大提高了，这并不是我们预期的结果&lt;/p>
&lt;h3 id="stcfshortest-time-to-completion-first">STCF(Shortest Time to Completion First)&lt;/h3>
&lt;p>为了解决以上的问题，我们可以允许任务在未执行完时切换到另外的一个周转时间短的任务进行执行
也就是在 SJF 的基础上添加抢占的特性&lt;/p>
&lt;p>STCF 也可称为 PSJF(Preemptive Shortest Job First)&lt;/p></description></item></channel></rss>